# AUTOGENERATED! DO NOT EDIT! File to edit: ../mnist_classifier.ipynb.

# %% auto 0
__all__ = ['iskaggle', 'creds', 'cred_path', 'path', 'train_full', 'label', 'image_df', 'np_image_array', 'image_tens',
           'stacked_img_tens', 'stacked_lable_tens', 'folder_path', 'dls', 'learn', 'lr_min', 'lr_steep', 'lr_valley']

# %% ../mnist_classifier.ipynb 2
import os
from pathlib import Path
import pandas as pd
import numpy as np
from fastai.vision.all import *
from fastai.vision.all import Image
from torchvision.utils import save_image

matplotlib.rc('image', cmap='Greys')

# %% ../mnist_classifier.ipynb 3
iskaggle = os.environ.get('KAGGLE_KERNEL_RUN_TYPE', '')
creds = ''

# %% ../mnist_classifier.ipynb 4
cred_path = Path('~/.kaggle/kaggle.json').expanduser()
if not cred_path.exists():
    cred_path.parent.mkdir(exist_ok=True)
    cred_path.write_text(creds)
    cred_path.chmod(0o600)

# %% ../mnist_classifier.ipynb 5
path = Path('digit-recognizer')

# %% ../mnist_classifier.ipynb 6
if not iskaggle and not path.exists():
    import zipfile, kaggle
    kaggle.api.competition_download_cli(str(path))
    zipfile.ZipFile(f'{path}.zip').extractall(path)

# %% ../mnist_classifier.ipynb 7
if iskaggle:
    path = Path('../input/digit-recognizer')
    ! pip install -q dataset

# %% ../mnist_classifier.ipynb 11
train_full = pd.read_csv(path/'train.csv')

# %% ../mnist_classifier.ipynb 12
label = train_full.iloc[:, :1]

# %% ../mnist_classifier.ipynb 13
image_df = train_full.iloc[:, 1:]

# %% ../mnist_classifier.ipynb 15
np_image_array = image_df.values
np_image_array, np_image_array.shape

# %% ../mnist_classifier.ipynb 16
image_tens = [tensor(x).float() for x in np_image_array]

# %% ../mnist_classifier.ipynb 17
stacked_img_tens = torch.stack(image_tens).float()/255

# %% ../mnist_classifier.ipynb 18
stacked_lable_tens = tensor(label).unsqueeze(1)

# %% ../mnist_classifier.ipynb 20
folder_path = Path('train')
if not folder_path.exists():
    folder_path.mkdir()
for i in range(stacked_img_tens.shape[0]):
    img = stacked_img_tens[i].reshape(28, 28)
    dest = (folder_path/label['label'][i].astype(str))
    dest.mkdir(exist_ok=True)
    img_path = Path(f"{dest}/{i}.png")
    if not img_path.exists():
        save_image(img, img_path)

# %% ../mnist_classifier.ipynb 21
dls = ImageDataLoaders.from_folder(folder_path, get_image_files(folder_path), bs=255, valid_pct=0.2, seed=42, label_func=parent_label)

# %% ../mnist_classifier.ipynb 22
learn = vision_learner(dls, resnet18, loss_func=F.cross_entropy, metrics=accuracy)

# %% ../mnist_classifier.ipynb 24
lr_min, lr_steep, lr_valley = learn.lr_find(suggest_funcs=(minimum, steep, valley))

# %% ../mnist_classifier.ipynb 25
lr_min = f"{lr_min:.2e}"
lr_steep = f"{lr_steep:.2e}"
lr_valley = f"{lr_valley:.2e}"

# %% ../mnist_classifier.ipynb 26
learn = vision_learner(dls, resnet18, loss_func=F.cross_entropy, metrics=accuracy)
